var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => importAssets
});
module.exports = __toCommonJS(src_exports);
var import_compiler = require("svelte/compiler");
var import_magic_string = __toESM(require("magic-string"));

// src/constants.ts
var IGNORE_FLAG = "svelte-preprocess-import-assets-ignore";
var DEFAULT_ASSET_PREFIX = "___ASSET___";
var ALLOWED_REL = [
  "stylesheet",
  "icon",
  "shortcut icon",
  "mask-icon",
  "apple-touch-icon",
  "apple-touch-icon-precomposed",
  "apple-touch-startup-image",
  "manifest",
  "prefetch",
  "preload"
];
var ALLOWED_ITEMPROP = [
  "image",
  "logo",
  "screenshot",
  "thumbnailurl",
  "contenturl",
  "downloadurl",
  "duringmedia",
  "embedurl",
  "installurl",
  "layoutimage"
];
var ALLOWED_META_NAME = [
  "msapplication-tileimage",
  "msapplication-square70x70logo",
  "msapplication-square150x150logo",
  "msapplication-wide310x150logo",
  "msapplication-square310x310logo",
  "msapplication-config",
  "twitter:image"
];
var ALLOWED_META_PROPERTY = [
  "og:image",
  "og:image:url",
  "og:image:secure_url",
  "og:audio",
  "og:audio:secure_url",
  "og:video",
  "og:video:secure_url",
  "vk:image"
];
var DEFAULT_SOURCES = [
  {
    tag: "audio",
    srcAttributes: ["src"]
  },
  {
    tag: "embed",
    srcAttributes: ["src"]
  },
  {
    tag: "img",
    srcAttributes: ["src"],
    srcsetAttributes: ["srcset"]
  },
  {
    tag: "input",
    srcAttributes: ["src"]
  },
  {
    tag: "object",
    srcAttributes: ["src"]
  },
  {
    tag: "source",
    srcAttributes: ["src"],
    srcsetAttributes: ["srcset"]
  },
  {
    tag: "track",
    srcAttributes: ["src"]
  },
  {
    tag: "video",
    srcAttributes: ["poster", "src"]
  },
  {
    tag: "image",
    srcAttributes: ["href", "xlink:href"]
  },
  {
    tag: "use",
    srcAttributes: ["href", "xlink:href"]
  },
  {
    tag: "link",
    srcAttributes: ["href"],
    srcsetAttributes: ["imagesrcset"],
    filter({ attribute, attributes }) {
      if (attributes.rel && ALLOWED_REL.includes(attributes.rel.trim().toLowerCase())) {
        return true;
      }
      if (attribute !== "imagesrcset" && attributes.itemprop && ALLOWED_ITEMPROP.includes(attributes.itemprop.trim().toLowerCase())) {
        return true;
      }
      return false;
    }
  },
  {
    tag: "meta",
    srcAttributes: ["content"],
    filter({ attributes }) {
      if (attributes.name && ALLOWED_META_NAME.includes(attributes.name.trim().toLowerCase())) {
        return true;
      }
      if (attributes.property && ALLOWED_META_PROPERTY.includes(attributes.property.trim().toLowerCase())) {
        return true;
      }
      if (attributes.itemprop && ALLOWED_ITEMPROP.includes(attributes.itemprop.trim().toLowerCase())) {
        return true;
      }
      return false;
    }
  }
];

// src/index.ts
function importAssets(options = {}) {
  let {
    sources = DEFAULT_SOURCES,
    importPrefix = DEFAULT_ASSET_PREFIX,
    http = false,
    urlFilter
  } = options;
  let hasCustomSources = false;
  if (typeof sources === "function") {
    hasCustomSources = true;
    sources = sources(DEFAULT_SOURCES);
  }
  let parse;
  return {
    markup(_0) {
      return __async(this, arguments, function* ({ content, filename }) {
        if (!parse) {
          parse = (yield import("svelte-parse-markup")).parse;
        }
        const s = new import_magic_string.default(content);
        const ast = parse(content, { filename });
        const imports = /* @__PURE__ */ new Map();
        function addImport(attributeValue) {
          const url = attributeValue.raw.trim();
          if (url.startsWith("#"))
            return;
          if (!http && /^https?:\/\//.test(url))
            return;
          if (urlFilter && !urlFilter(url))
            return;
          let importName = "";
          if (imports.has(url)) {
            importName = imports.get(url);
          } else {
            importName = importPrefix + imports.size;
            imports.set(url, importName);
          }
          s.update(attributeValue.start, attributeValue.end, `{${importName}}`);
        }
        let ignoreNextElement = false;
        (0, import_compiler.walk)(ast.html, {
          enter(node) {
            var _a2, _b;
            if (node.type === "Comment") {
              if (node.data.trim() === IGNORE_FLAG) {
                ignoreNextElement = true;
              }
            } else if (node.type === "Element" || hasCustomSources && node.type === "InlineComponent") {
              let getAttributes = function() {
                if (!lazyAttributes) {
                  lazyAttributes = {};
                  node.attributes.forEach((attr) => {
                    if (attr.value.length > 1 && attr.value[0].type !== "Text")
                      return;
                    lazyAttributes[attr.name] = attr.value[0].raw;
                  });
                }
                return lazyAttributes;
              };
              if (ignoreNextElement) {
                ignoreNextElement = false;
                return;
              }
              let lazyAttributes;
              for (let i = 0; i < sources.length; i++) {
                const source = sources[i];
                if (source.tag === node.name) {
                  let getAttrValue = function(attr) {
                    const attribute = node.attributes.find((v) => v.name === attr);
                    if (!attribute)
                      return;
                    if (attribute.value.length !== 1 || attribute.value[0].type !== "Text")
                      return;
                    if (source.filter && !source.filter({
                      tag: source.tag,
                      attribute: attr,
                      value: content.slice(attribute.start, attribute.end),
                      attributes: getAttributes()
                    }))
                      return;
                    return attribute.value[0];
                  };
                  (_a2 = source.srcAttributes) == null ? void 0 : _a2.forEach((attr) => {
                    const value = getAttrValue(attr);
                    if (!value)
                      return;
                    addImport(value);
                  });
                  (_b = source.srcsetAttributes) == null ? void 0 : _b.forEach((attr) => {
                    const value = getAttrValue(attr);
                    if (!value)
                      return;
                    const srcsetRegex = /\s*([^,\s]+).*?(?:,|$)\s*/gm;
                    let match;
                    while (match = srcsetRegex.exec(value.raw)) {
                      addImport({
                        raw: match[1],
                        start: value.start + match.index,
                        end: value.start + match.index + match[1].length
                      });
                    }
                  });
                }
              }
            }
          }
        });
        if (imports.size) {
          let importText = "";
          for (const [path, importName] of imports.entries()) {
            importText += `import ${importName} from "${path}";`;
          }
          if (ast.module) {
            s.appendLeft(ast.module.content.start, importText);
          } else if (ast.instance) {
            s.appendLeft(ast.instance.content.start, importText);
          } else {
            s.append(`<script>${importText}<\/script>`);
          }
        }
        return {
          code: s.toString(),
          map: s.generateMap()
        };
      });
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
