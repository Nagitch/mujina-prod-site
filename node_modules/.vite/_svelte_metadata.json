{"compilerOptions":{"css":"external","dev":true,"hydratable":true},"configFile":false,"extensions":[".svelte",".svelte.md",".md"],"preprocess":[{"markup":"async ({ content, filename }) => {\n\t\t\tconst extensionsParts = (extensions || [extension]).map((ext) =>\n\t\t\t\text.split('.').pop()\n\t\t\t);\n\t\t\tif (!extensionsParts.includes(filename.split('.').pop())) return;\n\n\t\t\tconst parsed = await parser.process({ contents: content, filename });\n\t\t\treturn {\n\t\t\t\tcode: parsed.contents ,\n\t\t\t\tdata: parsed.data ,\n\t\t\t\tmap: '',\n\t\t\t};\n\t\t}"},{"markup":"markup(_0) {\n      return __async(this, arguments, function* ({ content, filename }) {\n        if (!parse) {\n          parse = (yield import(\"svelte-parse-markup\")).parse;\n        }\n        const s = new MagicString(content);\n        const ast = parse(content, { filename });\n        const imports = /* @__PURE__ */ new Map();\n        function addImport(attributeValue) {\n          const url = attributeValue.raw.trim();\n          if (url.startsWith(\"#\"))\n            return;\n          if (!http && /^https?:\\/\\//.test(url))\n            return;\n          if (urlFilter && !urlFilter(url))\n            return;\n          let importName = \"\";\n          if (imports.has(url)) {\n            importName = imports.get(url);\n          } else {\n            importName = importPrefix + imports.size;\n            imports.set(url, importName);\n          }\n          s.update(attributeValue.start, attributeValue.end, `{${importName}}`);\n        }\n        let ignoreNextElement = false;\n        walk(ast.html, {\n          enter(node) {\n            var _a2, _b;\n            if (node.type === \"Comment\") {\n              if (node.data.trim() === IGNORE_FLAG) {\n                ignoreNextElement = true;\n              }\n            } else if (node.type === \"Element\" || hasCustomSources && node.type === \"InlineComponent\") {\n              let getAttributes = function() {\n                if (!lazyAttributes) {\n                  lazyAttributes = {};\n                  node.attributes.forEach((attr) => {\n                    if (attr.value.length > 1 && attr.value[0].type !== \"Text\")\n                      return;\n                    lazyAttributes[attr.name] = attr.value[0].raw;\n                  });\n                }\n                return lazyAttributes;\n              };\n              if (ignoreNextElement) {\n                ignoreNextElement = false;\n                return;\n              }\n              let lazyAttributes;\n              for (let i = 0; i < sources.length; i++) {\n                const source = sources[i];\n                if (source.tag === node.name) {\n                  let getAttrValue = function(attr) {\n                    const attribute = node.attributes.find((v) => v.name === attr);\n                    if (!attribute)\n                      return;\n                    if (attribute.value.length !== 1 || attribute.value[0].type !== \"Text\")\n                      return;\n                    if (source.filter && !source.filter({\n                      tag: source.tag,\n                      attribute: attr,\n                      value: content.slice(attribute.start, attribute.end),\n                      attributes: getAttributes()\n                    }))\n                      return;\n                    return attribute.value[0];\n                  };\n                  (_a2 = source.srcAttributes) == null ? void 0 : _a2.forEach((attr) => {\n                    const value = getAttrValue(attr);\n                    if (!value)\n                      return;\n                    addImport(value);\n                  });\n                  (_b = source.srcsetAttributes) == null ? void 0 : _b.forEach((attr) => {\n                    const value = getAttrValue(attr);\n                    if (!value)\n                      return;\n                    const srcsetRegex = /\\s*([^,\\s]+).*?(?:,|$)\\s*/gm;\n                    let match;\n                    while (match = srcsetRegex.exec(value.raw)) {\n                      addImport({\n                        raw: match[1],\n                        start: value.start + match.index,\n                        end: value.start + match.index + match[1].length\n                      });\n                    }\n                  });\n                }\n              }\n            }\n          }\n        });\n        if (imports.size) {\n          let importText = \"\";\n          for (const [path, importName] of imports.entries()) {\n            importText += `import ${importName} from \"${path}\";`;\n          }\n          if (ast.module) {\n            s.appendLeft(ast.module.content.start, importText);\n          } else if (ast.instance) {\n            s.appendLeft(ast.instance.content.start, importText);\n          } else {\n            s.append(`<script>${importText}<\\/script>`);\n          }\n        }\n        return {\n          code: s.toString(),\n          map: s.generateMap()\n        };\n      });\n    }"},{"script":"async script({ attributes, content, filename = \"\" }) {\n      const lang = attributes.lang;\n      if (!supportedScriptLangs.includes(lang))\n        return;\n      const transformResult = await transformWithEsbuild(content, filename, {\n        loader: lang,\n        target: \"esnext\",\n        tsconfigRaw: {\n          compilerOptions: {\n            importsNotUsedAsValues: \"preserve\",\n            preserveValueImports: true\n          }\n        }\n      });\n      return {\n        code: transformResult.code,\n        map: transformResult.map\n      };\n    }","style":"async ({ attributes, content, filename = \"\" }) => {\n    const lang = attributes.lang;\n    if (!supportedStyleLangs.includes(lang))\n      return;\n    if (!transform) {\n      let resolvedConfig;\n      if (style.__resolvedConfig) {\n        resolvedConfig = style.__resolvedConfig;\n      } else if (isResolvedConfig(config)) {\n        resolvedConfig = config;\n      } else {\n        resolvedConfig = await resolveConfig(\n          config,\n          process.env.NODE_ENV === \"production\" ? \"build\" : \"serve\"\n        );\n      }\n      transform = getCssTransformFn(resolvedConfig);\n    }\n    const moduleId = `${filename}.${lang}`;\n    const result = await transform(content, moduleId);\n    if (result.map?.sources?.[0] === moduleId) {\n      result.map.sources[0] = path10.basename(filename);\n    }\n    return {\n      code: result.code,\n      map: result.map ?? void 0\n    };\n  }"}]}